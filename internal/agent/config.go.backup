package // Config holds the configuration for a single storage instance (Nextcloud, HiDrive, HiDrive Legacy, or Dropbox)
type Config struct {
	InstanceName    string
	ServiceType     string // "nextcloud", "hidrive", "hidrive_legacy", or "dropbox"
	URL             string
	Username        string
	Password        string
	AccessToken     string // For HiDrive Legacy API only
	RefreshToken    string // For Dropbox OAuth2 and HiDrive Legacy OAuth2
	AppKey          string // For Dropbox OAuth2 (App Key)
	AppSecret       string // For Dropbox OAuth2 (App Secret)  
	ClientID        string // For HiDrive Legacy OAuth2
	ClientSecret    string // For HiDrive Legacy OAuth2
	TestFileSizeMB  int
	TestIntervalSec int
	TestChunkSizeMB int
}
	"fmt"
	"os"
	"strconv"
)

// Config holds the configuration for a single storage instance (Nextcloud, HiDrive, HiDrive Legacy, or Dropbox)
type Config struct {
	InstanceName    string
	ServiceType     string // "nextcloud", "hidrive", "hidrive_legacy", or "dropbox"
	URL             string
	Username        string
	Password        string
	AccessToken     string // For Dropbox API and HiDrive Legacy API
	RefreshToken    string // For Dropbox OAuth2 and HiDrive Legacy OAuth2
	AppKey          string // For Dropbox OAuth2 (App Key)
	AppSecret       string // For Dropbox OAuth2 (App Secret)  
	ClientID        string // For HiDrive Legacy OAuth2
	ClientSecret    string // For HiDrive Legacy OAuth2
	TestFileSizeMB  int
	TestIntervalSec int
	TestChunkSizeMB int
}

const (
	DefaultFileSizeMB  = 10
	DefaultIntervalSec = 300
	DefaultChunkSizeMB = 5 // Kleinere Chunks für HiDrive (5MB statt 10MB)
)

// LoadConfigs loads configurations for all specified Nextcloud, HiDrive, HiDrive Legacy, and Dropbox instances
func LoadConfigs() ([]*Config, error) {
	var configs []*Config

	// Nextcloud Instanzen
	i := 1
	for {
		urlKey := fmt.Sprintf("NC_INSTANCE_%d_URL", i)
		userKey := fmt.Sprintf("NC_INSTANCE_%d_USER", i)
		passKey := fmt.Sprintf("NC_INSTANCE_%d_PASS", i)
		url := os.Getenv(urlKey)
		if i == 1 && url == "" {
			// Noch nicht zwingend Fehler, andere Services könnten konfiguriert sein
			break
		}
		if url == "" {
			break
		}
		user := os.Getenv(userKey)
		pass := os.Getenv(passKey)
		if user == "" || pass == "" {
			return nil, fmt.Errorf("error: %s and %s must be set for instance %d", userKey, passKey, i)
		}
		fileSize, _ := strconv.Atoi(os.Getenv("TEST_FILE_SIZE_MB"))
		if fileSize == 0 {
			fileSize = DefaultFileSizeMB
		}
		if fileSize <= 0 {
			return nil, fmt.Errorf("error: TEST_FILE_SIZE_MB must be positive, got %d", fileSize)
		}
		interval, _ := strconv.Atoi(os.Getenv("TEST_INTERVAL_SECONDS"))
		if interval == 0 {
			interval = DefaultIntervalSec
		}
		if interval <= 0 {
			return nil, fmt.Errorf("error: TEST_INTERVAL_SECONDS must be positive, got %d", interval)
		}
		chunkSize, _ := strconv.Atoi(os.Getenv("TEST_CHUNK_SIZE_MB"))
		if chunkSize == 0 {
			chunkSize = DefaultChunkSizeMB
		}
		if chunkSize <= 0 {
			return nil, fmt.Errorf("error: TEST_CHUNK_SIZE_MB must be positive, got %d", chunkSize)
		}
		config := &Config{
			InstanceName:    url,
			ServiceType:     "nextcloud",
			URL:             url,
			Username:        user,
			Password:        pass,
			TestFileSizeMB:  fileSize,
			TestIntervalSec: interval,
			TestChunkSizeMB: chunkSize,
		}
		configs = append(configs, config)
		i++
	}

	// HiDrive Instanzen (WebDAV)
	j := 1
	for {
		urlKey := fmt.Sprintf("HIDRIVE_INSTANCE_%d_URL", j)
		userKey := fmt.Sprintf("HIDRIVE_INSTANCE_%d_USER", j)
		passKey := fmt.Sprintf("HIDRIVE_INSTANCE_%d_PASS", j)
		url := os.Getenv(urlKey)
		if j == 1 && url == "" && len(configs) == 0 {
			// Noch nicht zwingend Fehler, andere Services könnten konfiguriert sein
			break
		}
		if url == "" {
			break
		}
		user := os.Getenv(userKey)
		pass := os.Getenv(passKey)
		if user == "" || pass == "" {
			return nil, fmt.Errorf("error: %s and %s must be set for instance %d", userKey, passKey, j)
		}
		fileSize, _ := strconv.Atoi(os.Getenv("TEST_FILE_SIZE_MB"))
		if fileSize == 0 {
			fileSize = DefaultFileSizeMB
		}
		if fileSize <= 0 {
			return nil, fmt.Errorf("error: TEST_FILE_SIZE_MB must be positive, got %d", fileSize)
		}
		interval, _ := strconv.Atoi(os.Getenv("TEST_INTERVAL_SECONDS"))
		if interval == 0 {
			interval = DefaultIntervalSec
		}
		if interval <= 0 {
			return nil, fmt.Errorf("error: TEST_INTERVAL_SECONDS must be positive, got %d", interval)
		}
		chunkSize, _ := strconv.Atoi(os.Getenv("TEST_CHUNK_SIZE_MB"))
		if chunkSize == 0 {
			chunkSize = DefaultChunkSizeMB
		}
		if chunkSize <= 0 {
			return nil, fmt.Errorf("error: TEST_CHUNK_SIZE_MB must be positive, got %d", chunkSize)
		}
		config := &Config{
			InstanceName:    url,
			ServiceType:     "hidrive",
			URL:             url,
			Username:        user,
			Password:        pass,
			TestFileSizeMB:  fileSize,
			TestIntervalSec: interval,
			TestChunkSizeMB: chunkSize,
		}
		configs = append(configs, config)
		j++
	}

	// HiDrive Legacy Instanzen (HTTP REST API)
	l := 1
	for {
		tokenKey := fmt.Sprintf("HIDRIVE_LEGACY_INSTANCE_%d_TOKEN", l)
		clientIDKey := fmt.Sprintf("HIDRIVE_LEGACY_INSTANCE_%d_CLIENT_ID", l)
		clientSecretKey := fmt.Sprintf("HIDRIVE_LEGACY_INSTANCE_%d_CLIENT_SECRET", l)
		nameKey := fmt.Sprintf("HIDRIVE_LEGACY_INSTANCE_%d_NAME", l)

		token := os.Getenv(tokenKey)
		clientID := os.Getenv(clientIDKey)
		clientSecret := os.Getenv(clientSecretKey)

		if l == 1 && token == "" && len(configs) == 0 {
			// Prüfe ob andere Services konfiguriert sind
			if os.Getenv("DROPBOX_INSTANCE_1_TOKEN") == "" {
				// Noch nicht zwingend Fehler - könnte nur ein Service konfiguriert sein
				break
			}
		}
		if token == "" {
			break
		}

		instanceName := os.Getenv(nameKey)
		if instanceName == "" {
			instanceName = fmt.Sprintf("hidrive-legacy-instance-%d", l)
		}

		fileSize, _ := strconv.Atoi(os.Getenv("TEST_FILE_SIZE_MB"))
		if fileSize == 0 {
			fileSize = DefaultFileSizeMB
		}
		if fileSize <= 0 {
			return nil, fmt.Errorf("error: TEST_FILE_SIZE_MB must be positive, got %d", fileSize)
		}
		interval, _ := strconv.Atoi(os.Getenv("TEST_INTERVAL_SECONDS"))
		if interval == 0 {
			interval = DefaultIntervalSec
		}
		if interval <= 0 {
			return nil, fmt.Errorf("error: TEST_INTERVAL_SECONDS must be positive, got %d", interval)
		}
		chunkSize, _ := strconv.Atoi(os.Getenv("TEST_CHUNK_SIZE_MB"))
		if chunkSize == 0 {
			chunkSize = DefaultChunkSizeMB
		}
		if chunkSize <= 0 {
			return nil, fmt.Errorf("error: TEST_CHUNK_SIZE_MB must be positive, got %d", chunkSize)
		}

		config := &Config{
			InstanceName:    instanceName,
			ServiceType:     "hidrive_legacy",
			URL:             "https://api.hidrive.strato.com",
			AccessToken:     token,
			ClientID:        clientID,
			ClientSecret:    clientSecret,
			TestFileSizeMB:  fileSize,
			TestIntervalSec: interval,
			TestChunkSizeMB: chunkSize,
		}
		configs = append(configs, config)
		l++
	}

	// Dropbox Instanzen
	k := 1
	for {
		tokenKey := fmt.Sprintf("DROPBOX_INSTANCE_%d_TOKEN", k)
		nameKey := fmt.Sprintf("DROPBOX_INSTANCE_%d_NAME", k)
		refreshTokenKey := fmt.Sprintf("DROPBOX_INSTANCE_%d_REFRESH_TOKEN", k)
		appKeyKey := fmt.Sprintf("DROPBOX_INSTANCE_%d_APP_KEY", k)
		appSecretKey := fmt.Sprintf("DROPBOX_INSTANCE_%d_APP_SECRET", k)
		
		token := os.Getenv(tokenKey)
		refreshToken := os.Getenv(refreshTokenKey)
		appKey := os.Getenv(appKeyKey)
		appSecret := os.Getenv(appSecretKey)
		
		// Check if either legacy token OR all OAuth2 credentials are provided
		hasLegacyToken := token != ""
		hasOAuth2Creds := refreshToken != "" && appKey != "" && appSecret != ""
		
		if k == 1 && !hasLegacyToken && !hasOAuth2Creds && len(configs) == 0 {
			return nil, fmt.Errorf("error: at least NC_INSTANCE_1_URL, HIDRIVE_INSTANCE_1_URL, HIDRIVE_LEGACY_INSTANCE_1_TOKEN, DROPBOX_INSTANCE_1_TOKEN, or DROPBOX_INSTANCE_1_REFRESH_TOKEN (with APP_KEY/APP_SECRET) must be set")
		}
		if !hasLegacyToken && !hasOAuth2Creds {
			break
		}
		instanceName := os.Getenv(nameKey)
		if instanceName == "" {
			instanceName = fmt.Sprintf("dropbox-instance-%d", k)
		}
		fileSize, _ := strconv.Atoi(os.Getenv("TEST_FILE_SIZE_MB"))
		if fileSize == 0 {
			fileSize = DefaultFileSizeMB
		}
		if fileSize <= 0 {
			return nil, fmt.Errorf("error: TEST_FILE_SIZE_MB must be positive, got %d", fileSize)
		}
		interval, _ := strconv.Atoi(os.Getenv("TEST_INTERVAL_SECONDS"))
		if interval == 0 {
			interval = DefaultIntervalSec
		}
		if interval <= 0 {
			return nil, fmt.Errorf("error: TEST_INTERVAL_SECONDS must be positive, got %d", interval)
		}
		chunkSize, _ := strconv.Atoi(os.Getenv("TEST_CHUNK_SIZE_MB"))
		if chunkSize == 0 {
			chunkSize = DefaultChunkSizeMB
		}
		if chunkSize <= 0 {
			return nil, fmt.Errorf("error: TEST_CHUNK_SIZE_MB must be positive, got %d", chunkSize)
		}
		config := &Config{
			InstanceName:    instanceName,
			ServiceType:     "dropbox",
			URL:             "https://api.dropboxapi.com",
			AccessToken:     token,
			RefreshToken:    refreshToken,
			AppKey:          appKey,
			AppSecret:       appSecret,
			TestFileSizeMB:  fileSize,
			TestIntervalSec: interval,
			TestChunkSizeMB: chunkSize,
		}
		configs = append(configs, config)
		k++
	}

	if len(configs) == 0 {
		return nil, fmt.Errorf("error: no instances configured. Please set NC_INSTANCE_1_..., HIDRIVE_INSTANCE_1_..., HIDRIVE_LEGACY_INSTANCE_1_..., DROPBOX_INSTANCE_1_TOKEN, or DROPBOX_INSTANCE_1_REFRESH_TOKEN (with OAuth2 credentials)")
	}

	// Validate all configurations
	for i, cfg := range configs {
		if err := validateConfig(cfg); err != nil {
			return nil, fmt.Errorf("configuration validation failed for instance %d: %w", i+1, err)
		}
		fmt.Printf("[Config] Validated instance: %s, ServiceType: %s, URL: %s\n", cfg.InstanceName, cfg.ServiceType, cfg.URL)
	}

	// Debug: Log all loaded configs
	for _, c := range configs {
		fmt.Printf("[Config] Loaded instance: %s, ServiceType: %s, URL: %s\n", c.InstanceName, c.ServiceType, c.URL)
	}
	return configs, nil
}

// validateConfig validates a single configuration instance
func validateConfig(cfg *Config) error {
	if cfg.InstanceName == "" {
		return fmt.Errorf("instance name cannot be empty")
	}

	switch cfg.ServiceType {
	case "nextcloud", "hidrive":
		if cfg.URL == "" {
			return fmt.Errorf("URL cannot be empty for %s", cfg.ServiceType)
		}
		if cfg.Username == "" {
			return fmt.Errorf("username cannot be empty for %s", cfg.ServiceType)
		}
		if cfg.Password == "" {
			return fmt.Errorf("password cannot be empty for %s", cfg.ServiceType)
		}
	case "hidrive_legacy":
		if cfg.AccessToken == "" {
			return fmt.Errorf("access token cannot be empty for HiDrive Legacy")
		}
		// ClientID und ClientSecret sind optional - werden nur für Token-Refresh benötigt
	case "dropbox":
		if cfg.AccessToken == "" {
			return fmt.Errorf("access token cannot be empty for Dropbox")
		}
	default:
		return fmt.Errorf("unsupported service type: %s", cfg.ServiceType)
	}

	if cfg.TestFileSizeMB <= 0 {
		return fmt.Errorf("test file size must be positive, got %d", cfg.TestFileSizeMB)
	}
	if cfg.TestIntervalSec <= 0 {
		return fmt.Errorf("test interval must be positive, got %d", cfg.TestIntervalSec)
	}
	if cfg.TestChunkSizeMB <= 0 {
		return fmt.Errorf("chunk size must be positive, got %d", cfg.TestChunkSizeMB)
	}

	return nil
}
